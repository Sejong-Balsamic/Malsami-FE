# 🎯 Malsami-FE 프로젝트 개발 가이드라인

> **Cursor AI 사용 시**: `@코드스타일_가이드라인` 으로 이 문서를 참조하세요!

---

## 📋 목차

### 🏗️ [프로젝트 구조](#프로젝트-구조)

### 📝 [명명 규칙](#명명-규칙)

### 🧩 [컴포넌트 작성법](#컴포넌트-작성법)

### 🎨 [스타일링 & 디자인 시스템](#스타일링--디자인-시스템)

### 🚨 [동적 레이아웃 구현 원칙](#동적-레이아웃-구현-원칙-매우-중요)

### 📐 [CSS to 테일윈드 변환 가이드](#css-to-테일윈드-변환-가이드)

### 📊 [타입 정의](#타입-정의)

### ⏳ [Skeleton UI](#skeleton-ui)

### 🔄 [상태 관리](#상태-관리)

### 🌐 [API 통신](#api-통신)

### 📝 [컴포넌트 템플릿](#컴포넌트-템플릿)

### ✨ [코드 품질](#코드-품질)

---

## 🏗️ 프로젝트 구조

### 폴더 구조 규칙

```
src/
├── components/          # 재사용 가능한 UI 컴포넌트
│   ├── common/         # 공통 컴포넌트
│   ├── [feature]/      # 기능별 컴포넌트 (ex: documentMain, questionPost)
│   └── shadcn/         # Shadcn UI 컴포넌트
├── apis/               # API 관련 함수들
├── types/              # TypeScript 타입 정의
├── global/             # 전역 상태 및 유틸리티
│   ├── store/          # Redux 스토어 슬라이스
│   └── hook/           # 커스텀 훅
├── app/                # Next.js App Router 페이지
└── deprecated/         # 사용하지 않는 레거시 코드
```

### 파일 분리 기준

- **50줄 이상** → 분리 고려
- **재사용성 있음** → common 폴더로 분리
- **독립적 기능** → 별도 컴포넌트로 분리

---

## 📝 명명 규칙

### 기본 원칙

- **명확성 우선**: 간결함보다 명확성과 정확성을 우선시
- **독특함과 직관성**: 흔한 패턴을 피하되 직관적이어야 함
- **자체 설명**: 추가 주석 없이도 의도가 명확해야 함

### 1. 파일 및 폴더명

```typescript
// ✅ 컴포넌트: PascalCase
DocumentUploadCard.tsx;
QuestionAnswerForm.tsx;
UserProfileHeader.tsx;

// ✅ 유틸/헬퍼: camelCase
documentValidator.ts;
questionFormatter.ts;
userAuthenticationHelper.ts;

// ❌ 나쁜 예
docboardcard.tsx; // 전부 소문자
doc - board - card.tsx; // kebab-case
Card.tsx; // 너무 일반적
DBC.tsx; // 축약어
```

### 2. 변수명 (매우 중요!)

#### Boolean 변수 - 반드시 is 접두사 사용

```typescript
// ✅ Boolean 변수는 반드시 is 접두사 사용
const isLoading = useState<boolean>(false);
const isModalOpen = useState<boolean>(false);
const isDocumentValid = true;
const isUserAuthenticated = false;

// ❌ 절대 금지
const loading = useState<boolean>(false); // boolean인데 is 접두사 없음
const modalopen = useState<boolean>(false); // camelCase 아님
const hasPermission = true; // has 사용 금지
const canEdit = false; // can 사용 금지
const shouldUpdate = true; // should 사용 금지
```

#### 일반 변수 - 3가지 명명 스타일 권장

**1. 설명적 스타일 (상세한 맥락이 중요한 경우)**

```typescript
const userAuthenticationTimestamp = Date.now();
const documentSubmissionDeadlineDate = new Date();
const questionResponseValidationResult = validateResponse();
```

**2. 균형 스타일 (가장 일반적)**

```typescript
const loginTimestamp = Date.now();
const submissionDeadline = new Date();
const validationResult = validateResponse();
```

**3. 창의적 스타일 (독특하지만 직관적)**

```typescript
const entryMoment = Date.now();
const deadlineHorizon = new Date();
const responseVerdict = validateResponse();
```

#### 명명 패턴

- **주체 + 동작 + 데이터타입**: `userLoginTimestamp`
- **동작 + 데이터타입**: `submissionResult`
- **맥락 + 이벤트 + 데이터타입**: `sessionStartTime`

### 3. 함수/메소드명

#### 동작 중심 명명

```typescript
// ✅ 명확한 동작 표현
function validateUserCredentials() {}
function transformDocumentData() {}
function generateQuestionSummary() {}

// ❌ 모호한 표현
function validate() {}
function transform() {}
function generate() {}
```

#### 반환값이 Boolean인 경우

```typescript
// ✅ 질문 형태로 명명
function hasValidCredentials(): boolean {}
function canSubmitDocument(): boolean {}
function shouldDisplayQuestion(): boolean {}
```

#### 이벤트 핸들러

```typescript
const handleDocumentUpload = () => {};
const handleQuestionSubmission = () => {};
const handleUserLogout = () => {};
```

### 4. 클래스명

```typescript
// ✅ 명사 중심 + 역할 명시
class DocumentValidator {}
class QuestionRepository {}
class UserAuthenticationService {}
class PaymentCalculationEngine {}

// ❌ 모호한 클래스명
class Utils {}
class Helper {}
class Manager {}
```

### 5. 상수명

```typescript
// ✅ UPPER_SNAKE_CASE
const MAX_DOCUMENT_SIZE_BYTES = 1024 * 1024;
const DEFAULT_QUESTION_TIMEOUT_SECONDS = 30;
const API_ENDPOINTS = {
  DOCUMENT_UPLOAD: "/api/documents",
  QUESTION_SUBMIT: "/api/questions",
};

const CONTENT_TYPE = {
  DOCUMENT: "DOCUMENT",
  QUESTION: "QUESTION",
} as const;
```

### 6. 컴포넌트명

```typescript
// ✅ PascalCase + 역할 명시
const DocumentUploadCard = () => {};
const QuestionAnswerForm = () => {};
const UserProfileHeader = () => {};

// ❌ 모호한 컴포넌트명
const Card = () => {};
const Form = () => {};
const Header = () => {};
```

### 7. 맥락별 명명 가이드

#### API 관련

```typescript
const documentUploadEndpoint = "/api/documents/upload";
const questionSubmissionResponse = await submitQuestion();
const userAuthenticationToken = getAuthToken();
```

#### 상태 관리

```typescript
const [isDocumentUploading, setIsDocumentUploading] = useState(false);
const [questionFormData, setQuestionFormData] = useState({});
const [userSessionExpiry, setUserSessionExpiry] = useState(null);
```

### 8. 절대 금지 사항

```typescript
// ❌ 축약어 사용 금지
const doc = document; // document 그대로 사용
const q = question; // question 그대로 사용
const QNA = questionAnswer; // questionAnswer 그대로 사용

// ❌ 의미 없는 변수명
const data = response;
const item = user;
const temp = calculation;

// ❌ any 타입과 모호한 명명
const result: any = api();
const value = getValue();
```

### 9. 예외 상황 (짧은 이름 허용)

다음의 경우에만 짧은 이름 허용:

- 반복문의 인덱스: `i`, `j`, `k`
- 매우 짧은 스코프의 임시 변수
- 수학적 계산의 표준 변수명: `x`, `y`, `z`

```typescript
// ✅ 허용되는 짧은 이름
for (let i = 0; i < documents.length; i++) {
  const document = documents[i];
}

// 수학 계산
const distance = Math.sqrt(x * x + y * y);
```

### 10. 명명 체크리스트

새로운 이름을 정할 때 다음을 확인하세요:

- [ ] 축약어를 사용하지 않았는가?
- [ ] Boolean 변수에 is 접두사를 사용했는가?
- [ ] 추가 설명 없이도 의도가 명확한가?
- [ ] 프로젝트 내 다른 이름들과 일관성이 있는가?
- [ ] 너무 일반적이거나 모호하지 않은가?
- [ ] 맥락에 맞는 명명 패턴을 따랐는가?

---

## 🧩 컴포넌트 작성법

### 기본 컴포넌트 구조 (반드시 준수!)

```typescript
"use client"; // 클라이언트 컴포넌트인 경우에만

import React, { useState, useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";

interface ComponentNameProps {
  title: string;
  isVisible?: boolean;
  onClose?: () => void;
}

/**
 * [컴포넌트 설명]
 *
 * @param title - 컴포넌트 제목
 * @param isVisible - 표시 여부 (기본값: true)
 */
export default function ComponentName({
  title,
  isVisible = true,
  onClose
}: ComponentNameProps) {
  // 1. 훅 선언
  const dispatch = useDispatch();
  const stateValue = useSelector((state: RootState) => state.someState);

  // 2. 상태 선언
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [data, setData] = useState<DataType[]>([]);

  // 3. 이벤트 핸들러
  const handleClick = () => {
    // 핸들러 로직
  };

  // 4. useEffect
  useEffect(() => {
    // 사이드 이펙트
  }, []);

  // 5. 조건부 렌더링
  if (isLoading) {
    return <ComponentNameSkeleton />;
  }

  if (!isVisible) {
    return null;
  }

  // 6. 메인 렌더링
  return (
    <div className="component-wrapper">
      {/* 컴포넌트 내용 */}
    </div>
  );
}
```

### Props 인터페이스 규칙

```typescript
// ✅ Props 인터페이스는 컴포넌트명 + Props
interface DocBoardCardProps {
  tier: PostTiersKey;
  link: string;
  accessible: boolean;
}

// ❌ 절대 금지
interface Props { ... }                    // 너무 일반적
interface IDocBoardCardProps { ... }       // I 접두사 사용 금지
```

---

## 🎨 스타일링 & 디자인 시스템

### 색상 시스템 (반드시 준수!)

#### 브랜드 색상

```css
/* Blue - 메인 브랜드 색상 */
custom-blue-100: #95E4DA  /* 매우 연한 파랑 */
custom-blue-200: #74D7CB  /* 연한 파랑 */
custom-blue-300: #55CDBB  /* 중간 파랑 */
custom-blue-400: #09BBA2  /* 진한 파랑 */
custom-blue-500: #03B89E  /* 메인 파랑 (기본) */

/* Green - 보조 색상 */
custom-green-100: #AAE483  /* 매우 연한 초록 */
custom-green-500: #5ED513  /* 메인 초록 */

/* Orange - 강조 색상 */
custom-orange-100: #F2AB75  /* 매우 연한 주황 */
custom-orange-500: #F46B02  /* 메인 주황 */
```

#### 색상 사용 가이드

```typescript
// ✅ 정의된 색상만 사용
className = "bg-custom-blue-500 text-white";
className = "border-custom-green-300";
className = "text-custom-orange-400";

// ✅ 시맨틱 색상 (Shadcn UI)
className = "bg-background text-foreground";
className = "border-border bg-card";

// ❌ 절대 금지 - 하드코딩된 색상
className = "bg-[#03B89E]"; // 대신 custom-blue-500 사용
className = "text-[rgb(255,255,255)]"; // 대신 text-white 사용
```

#### 색상별 용도

- **Primary (custom-blue-500)**: 주요 CTA 버튼, 링크, 활성 상태
- **Success (custom-green-500)**: 성공 메시지, 완료 상태, 채택된 답변
- **Warning (custom-orange-500)**: 경고 메시지, 중요한 정보, 엽전 관련
- **Error (red-500)**: 에러 메시지, 삭제 버튼, 위험한 액션
- **Neutral (gray-500)**: 일반 버튼, 비활성 상태, 취소 버튼

### 타이포그래피

#### SUIT 폰트 사용법 (프로젝트 기본 폰트)

```typescript
// ✅ SUIT 폰트 크기별 사용 가이드
className="text-SUIT_24 font-bold"     // 대제목 - 24px Bold
className="text-SUIT_20 font-bold"     // 중제목 - 20px Bold
className="text-SUIT_18 font-semibold" // 소제목 - 18px Semibold
className="text-SUIT_16 font-medium"   // 메인라벨 - 16px Medium
className="text-SUIT_14 font-medium"   // 본문 - 14px Medium
className="text-SUIT_12 font-medium"   // 바디 - 12px Medium

// ✅ 용도별 사용 예시
className="text-SUIT_24 font-bold"     // 페이지 제목
className="text-SUIT_18 font-semibold" // 섹션 제목, 탭 텍스트
className="text-SUIT_16 font-medium"   // 카드 제목, 버튼 텍스트
className="text-SUIT_14 font-medium"   // 본문 텍스트, 설명
className="text-SUIT_12 font-medium"   // 태그, 메타 정보

// ❌ 절대 금지 - 인라인 스타일
style={{ fontFamily: 'SUIT', fontSize: '18px' }}
```

#### 타이포그래피 가이드

```typescript
// 페이지 제목
className = "font-suit-bold text-3xl text-foreground mb-6";

// 섹션 제목
className = "font-suit-semibold text-xl text-foreground mb-4";

// 카드 제목
className = "font-pretendard-semibold text-lg text-foreground mb-2";

// 본문 텍스트
className = "font-pretendard-regular text-base text-foreground leading-relaxed";

// 보조 텍스트
className = "font-pretendard-regular text-sm text-muted-foreground";

// 태그/라벨
className = "font-pretendard-medium text-xs text-muted-foreground uppercase";
```

### 컴포넌트 스타일 (자주 사용)

#### 버튼 스타일

```typescript
// Primary 버튼
className =
  "bg-custom-blue-500 hover:bg-custom-blue-400 text-white font-pretendard-medium px-4 py-2 rounded-md transition-colors";

// Secondary 버튼
className =
  "bg-secondary hover:bg-secondary/80 text-secondary-foreground font-pretendard-medium px-4 py-2 rounded-md transition-colors";

// Outline 버튼
className =
  "border border-border hover:bg-secondary text-foreground font-pretendard-medium px-4 py-2 rounded-md transition-colors";

// Destructive 버튼
className = "bg-red-500 hover:bg-red-400 text-white font-pretendard-medium px-4 py-2 rounded-md transition-colors";
```

#### 카드 스타일

```typescript
// 기본 카드
className = "bg-card border border-border rounded-lg p-6 shadow-sm";

// 호버 가능한 카드
className = "bg-card border border-border rounded-lg p-6 shadow-sm hover:shadow-md transition-shadow cursor-pointer";

// 선택된 카드
className = "bg-card border-2 border-custom-blue-500 rounded-lg p-6 shadow-md";
```

#### 입력 필드 스타일

```typescript
// 기본 입력 필드
className =
  "w-full px-3 py-2 border border-input rounded-md bg-background text-foreground placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-custom-blue-500 focus:border-transparent";

// 에러 상태 입력 필드
className =
  "w-full px-3 py-2 border border-red-500 rounded-md bg-background text-foreground placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent";
```

#### 태그 스타일

```typescript
// 기본 태그
className =
  "inline-flex items-center px-2 py-1 rounded-full text-xs font-pretendard-medium bg-secondary text-secondary-foreground";

// Blue 태그
className =
  "inline-flex items-center px-2 py-1 rounded-full text-xs font-pretendard-medium bg-custom-blue-100 text-custom-blue-500";

// Green 태그
className =
  "inline-flex items-center px-2 py-1 rounded-full text-xs font-pretendard-medium bg-custom-green-100 text-custom-green-500";

// Orange 태그
className =
  "inline-flex items-center px-2 py-1 rounded-full text-xs font-pretendard-medium bg-custom-orange-100 text-custom-orange-500";
```

### 반응형 디자인

```typescript
// 브레이크포인트: xs: 375px, sm: 640px, md: 768px, lg: 1024px, xl: 1280px, 2xl: 1536px

// 그리드 레이아웃
className = "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4";

// 텍스트 크기
className = "text-sm md:text-base lg:text-lg";

// 간격 조절
className = "p-4 md:p-6 lg:p-8";

// 숨김/표시
className = "hidden md:block"; // 모바일에서 숨김
className = "block md:hidden"; // 데스크톱에서 숨김
```

### 간격 시스템

```css
/* Tailwind 간격 (1 = 0.25rem = 4px) */
gap-1, p-1, m-1     /* 4px - 매우 작은 간격 */
gap-2, p-2, m-2     /* 8px */
gap-3, p-3, m-3     /* 12px - 작은 간격 */
gap-4, p-4, m-4     /* 16px */
gap-6, p-6, m-6     /* 24px - 중간 간격 */
gap-8, p-8, m-8     /* 32px */
gap-12, p-12, m-12  /* 48px - 큰 간격 */
```

#### 컴포넌트별 간격

```typescript
// 카드 컴포넌트
className = "p-6 space-y-4"; // 내부 여백 24px, 요소 간격 16px

// 리스트 아이템
className = "py-3 px-4 space-y-2"; // 세로 여백 12px, 가로 여백 16px

// 폼 요소
className = "space-y-4 p-6"; // 필드 간격 16px, 폼 여백 24px

// 버튼
className = "px-4 py-2"; // 기본 버튼 여백
className = "px-6 py-3"; // 큰 버튼 여백
className = "px-3 py-1"; // 작은 버튼 여백
```

---

## 🚨 동적 레이아웃 구현 원칙 (매우 중요!)

### 핵심 원칙: 디자인 가이드 → 개발 구현

**디자이너가 고정값으로 제시하더라도, 개발에서는 반드시 동적/반응형으로 구현해야 합니다.**

#### ❌ 절대 금지 - 하드코딩된 크기

```typescript
// ❌ 디자인 가이드 그대로 하드코딩
className="w-[271px]"           // 고정 너비
className="w-[393px] h-[60px]"  // 고정 컨테이너 크기
className="left-[20px]"         // 고정 위치값
style={{ width: '271px' }}     // 인라인 스타일

// ❌ 픽셀 기준 계산 하드코딩
const width = 393 - 40 - 70 - 12; // 271px 계산
```

#### ✅ 올바른 방법 - 동적 계산

```typescript
// ✅ Flex 기반 동적 레이아웃
<div className="flex items-start gap-3">
  <div className="flex-1 min-w-0">  {/* 나머지 모든 공간 차지 */}
    <p className="line-clamp-2">    {/* 동적 너비로 텍스트 표시 */}
  </div>
  <div className="flex-shrink-0">   {/* 고정 요소 */}
    <div className="w-[4.375rem] h-[4.375rem]"> {/* rem 단위 사용 */}
```

#### ✅ 반응형 크기 단위

```typescript
// ✅ rem 기준 (16px = 1rem)
className="w-[4.375rem]"  // 70px → 4.375rem
className="h-[2.5rem]"    // 40px → 2.5rem
className="gap-3"         // 12px → 0.75rem

// ✅ 상대적 크기
className="w-full"        // 부모 기준 100%
className="w-1/2"         // 부모 기준 50%
className="flex-1"        // 나머지 모든 공간

// ✅ Grid 기반
className="grid grid-cols-[1fr_4.375rem]" // 동적:고정 비율
```

#### 🎯 레이아웃 패턴별 구현

**1. 텍스트 + 이미지 레이아웃**
```typescript
// 디자인: "본문 271px, 이미지 70px, 간격 12px"
// 구현: flex + gap으로 동적 처리
<div className="flex gap-3">
  <div className="flex-1 min-w-0">{/* 텍스트 */}</div>
  <div className="w-[4.375rem] h-[4.375rem]">{/* 이미지 */}</div>
</div>
```

**2. 컨테이너 기준 계산**
```typescript
// 디자인: "전체 393px - 좌우패딩 40px = 353px"
// 구현: px-5 + flex로 자동 계산
<div className="px-5">  {/* 좌우 20px씩 */}
  <div className="flex gap-3">  {/* 나머지 공간 자동 분배 */}
```

**3. 반응형 간격**
```typescript
// ✅ Tailwind 간격 시스템 활용
className="gap-1"     // 4px
className="gap-2"     // 8px  
className="gap-3"     // 12px ← 주로 사용
className="gap-4"     // 16px
className="gap-6"     // 24px
```

#### ⚠️ 주의사항

1. **픽셀값 제시 = 참고용**: 실제로는 비율과 관계를 파악해서 구현
2. **컨테이너 기준 계산**: 부모 요소에서 차지할 공간 비율로 사고
3. **모바일 우선**: 작은 화면에서부터 설계
4. **최소값 설정**: `min-w-0`, `min-h-0`로 오버플로우 방지

#### 📱 실무 적용 예시

```typescript
// 디자인 가이드: "QuestionCard 본문 271px"
// 분석: 전체(393px) - 패딩(40px) - 이미지(70px) - 간격(12px) = 271px
// 구현: flex로 자동 계산

// ❌ 잘못된 구현
<div className="w-[271px]">
  <p className="line-clamp-2">텍스트</p>
</div>

// ✅ 올바른 구현  
<div className="flex gap-3">
  <div className="flex-1 min-w-0">
    <p className="line-clamp-2">텍스트</p>  {/* 동적 너비 */}
  </div>
  <div className="w-[4.375rem] flex-shrink-0">이미지</div>
</div>
```

---

## 📐 CSS to 테일윈드 변환 가이드

### 기본 설계 원칙

#### 📱 화면 기준

- **기본 화면**: iPhone 16 크기 기준으로 설계 (375px 너비)
- **기본 패딩**: `px-5` (20px) - 프로젝트 표준 좌우 패딩
- **반응형 우선**: 고정 픽셀이 아닌 상대적 크기 사용

#### 🎯 CSS → 테일윈드 변환 규칙

**절대 금지:**

```typescript
// ❌ 인라인 스타일 사용 금지
style={{
  width: '361px',
  height: '64px',
  borderRadius: '14px'
}}
```

**권장 방법:**

```typescript
// ✅ 테일윈드 클래스 활용
className = "w-full h-16 rounded-2xl";
```

#### 📏 크기 변환 가이드

**고정 크기 → 반응형:**

```css
/* CSS 제시안 (iPhone 16 기준) */
width: 361px; → w-full (컨테이너에 맞춰 확장)
width: 44px;  → w-11 (44px = 11 * 4px)
height: 64px; → h-16 (64px = 16 * 4px)
```

**간격 변환:**

```css
/* CSS 제시안 → 테일윈드 */
gap: 6px;     → gap-1.5 또는 space-x-1.5
margin: 20px; → m-5 (20px = 5 * 4px)
padding: 16px; → p-4 (16px = 4 * 4px)
```

**둥근 모서리:**

```css
border-radius: 14px; → rounded-2xl (16px, 가장 가까운 값)
border-radius: 8px;  → rounded-lg
border-radius: 12px; → rounded-xl
```

**색상:**

```css
background: #D9FFD4; → bg-[#D9FFD4] (커스텀 색상)
color: #08E4BA;      → text-[#08E4BA] (브랜드 색상)
```

#### 🔄 텍스트 오버플로우 처리

**기존 CSS 방식:**

```css
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 1;
overflow: hidden;
text-overflow: ellipsis;
```

**테일윈드 방식:**

```typescript
className = "truncate"; // 1줄 제한
className = "line-clamp-2"; // 2줄 제한 (plugin 필요)
```

#### 📱 반응형 레이아웃 패턴

**Flex 컨테이너:**

```typescript
// 기본 패턴
className = "flex items-center justify-between";

// 반응형 텍스트용
className = "flex-1 min-w-0"; // 텍스트 영역
className = "flex-shrink-0"; // 아이콘/버튼 영역
```

**패딩 적응:**

```typescript
// 기본: px-5 (20px) - 프로젝트 표준 좌우 패딩
// 모든 페이지 컨테이너에 적용
className = "px-5 w-full"; // 좌우 20px 패딩
className = "pb-[61px]"; // 하단 여백 (모바일 탭바 고려)
```

#### ⚠️ 주의사항

1. **픽셀 값 제시 시**: iPhone 16 기준이므로 반응형으로 변환
2. **고정 너비 금지**: `width: 361px` 등은 `w-full` 사용
3. **테일윈드 우선**: 인라인 스타일 최소화
4. **브레이크포인트**: `sm:`, `md:`, `lg:` 적극 활용

#### 🚫 동적 CSS 변환 원칙 (매우 중요!)

**사용자가 제공해주는 피그마 디자인은 고정 크기 기준이므로 반드시 동적으로 변환해야 합니다:**

```typescript
// ❌ 절대 금지 - 피그마 고정값 그대로 사용
className = "w-[393px] h-[60px]";           // 피그마 기준 하드코딩
className = "w-[176px]";                    // 활성바 고정 크기
style={{ width: '393px', height: '60px' }}; // 인라인 하드코딩

// ✅ 올바른 방법 - 동적 계산
className = "w-full h-15";                  // 컨테이너에 맞춤
className = "w-1/2";                        // 부모 기준 50%
className = "left-1/4 w-1/2";              // 중앙 정렬, 절반 크기
```

**동적 변환 예시:**

```typescript
// 피그마: width: 176px (활성바), 전체: 353px (기본바)
// → 176/353 ≈ 50% → w-1/2

// 피그마: 좌우 14px 여백
// → left-[14px] right-[14px] 대신 px-[14px] 사용

// 피그마: 중앙 정렬
// → 절대 위치 대신 flex justify-center 사용
```

**컨테이너 기준 계산:**

```typescript
// 피그마 393px 기준 → 실제 디바이스 width 기준
// 393px - 40px(좌우패딩) = 353px 실제 콘텐츠 영역
// 176px / 353px = 약 50% → w-1/2
```

---

## 📊 타입 정의

### 타입 파일 구조

```
src/types/
├── api/
│   ├── constants/      # API 상수들
│   ├── entities/       # 데이터 엔티티
│   ├── requests/       # API 요청 타입
│   └── responses/      # API 응답 타입
├── components/         # 컴포넌트 관련 타입
└── global/            # 전역 타입
```

### 타입 정의 규칙

```typescript
// ✅ 인터페이스 사용 (확장 가능성)
interface UserProfile {
  id: string;
  name: string;
  email: string;
}

// ✅ const assertion 사용
export const ContentType = {
  DOCUMENT: "DOCUMENT",
  QUESTION: "QUESTION",
} as const;

export type ContentType = keyof typeof ContentType;

// ✅ 유니온 타입
type PostTier = "CHEONMIN" | "JUNGIN" | "YANGBAN" | "KING";

// ❌ 절대 금지
const data: any = fetchData(); // 대신 명확한 타입 정의
```

---

## ⏳ Skeleton UI

### Skeleton 규칙 (매우 중요!)

#### 1. 위치 및 명명

```
src/components/common/skeletons/
├── MovingCardSkeleton.tsx
├── QuestionCardSkeleton.tsx
├── DocumentCardSkeleton.tsx
└── index.ts  // 모든 skeleton export
```

#### 2. 명명 규칙

```typescript
// ✅ 원본 컴포넌트명 + Skeleton
MovingCard → MovingCardSkeleton
QuestionCard → QuestionCardSkeleton
DocBoardCard → DocBoardCardSkeleton

// ❌ 절대 금지
MovingCardLoading
QuestionSkeleton  // Card가 빠짐
LoadingMovingCard
```

#### 3. Skeleton 구조

```typescript
// ✅ 기본 Skeleton 구조
export default function ComponentNameSkeleton() {
  return (
    <div className="animate-pulse">
      {/* 원본 컴포넌트와 같은 구조 유지 */}
      <div className="h-6 w-24 rounded bg-gray-200 mb-4" />
      <div className="h-4 w-full rounded bg-gray-200 mb-2" />
      <div className="h-4 w-3/4 rounded bg-gray-200" />
    </div>
  );
}

// ✅ 배열 렌더링 시 unique key 사용
{Array.from({ length: 3 }, (_, index) => (
  <ComponentSkeleton key={`skeleton-${index}`} />
))}
```

#### 4. 사용 방법

```typescript
// ✅ 로딩 상태에 따른 조건부 렌더링
export default function DataList() {
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [data, setData] = useState<DataType[]>([]);

  if (isLoading) {
    return <DataListSkeleton />;
  }

  return (
    <div>
      {data.map(item => (
        <DataCard key={item.id} data={item} />
      ))}
    </div>
  );
}
```

---

## 🔄 상태 관리

### Redux Slice 구조

```typescript
// ✅ 슬라이스 파일 명명: [feature]Slice.ts
// global/store/bottomSheetSlice.ts
interface BottomSheetState {
  isOpen: boolean;
}

const bottomSheetSlice = createSlice({
  name: "bottomSheet", // camelCase
  initialState,
  reducers: {
    setIsOpen: (state, action: PayloadAction<boolean>) => {
      state.isOpen = action.payload;
    },
  },
});
```

### 커스텀 훅 규칙

```typescript
// ✅ 커스텀 훅 명명
const useUserPermissions = () => { ... };
const useToast = () => { ... };
const useLogout = () => { ... };

// ✅ 훅 내부 구조
export function useUserPermissions() {
  const [memberDto, setMemberDto] = useState<MemberDto | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);

  useEffect(() => {
    // 로직
  }, []);

  return { memberDto, isLoading };
}
```

---

## 🌐 API 통신

### API 파일 구조

```
src/apis/
├── appClient.ts          # Axios 인스턴스
├── apiUtils.ts          # API 공통 유틸리티
├── authApi.ts           # 인증 관련 API
├── documentApi.ts       # 문서 관련 API
├── questionApi.ts       # 질문 관련 API
└── document/            # 이외 폴더내부 파일들은 deprecated API 사용하지않습니다

```

### API 함수 명명

- 백엔드 코드가 너무 복잡하여 아마 API 로직은 동기화 시킵니다
- 스프링부트 Controller 코드와 Model 코드를 제공하여 동기화 시키면서 업데이트합니다

```typescript
// ✅ 동사 + 명사 형태
export const fetchDocuments = async (): Promise<DocumentDto[]> => { ... };
export const createDocument = async (data: DocumentCommand): Promise<DocumentDto> => { ... };
export const updateDocument = async (id: string, data: DocumentCommand): Promise<DocumentDto> => { ... };
export const deleteDocument = async (id: string): Promise<void> => { ... };

// ❌ 절대 금지
export const documents = async () => { ... };        // 동사가 없음
export const getDocumentList = async () => { ... };  // get보다 fetch 선호
```

### 에러 처리

```typescript
// ✅ API 함수에서 에러 처리
export const fetchDocuments = async (): Promise<DocumentResponse[]> => {
  try {
    const response = await appClient.get("/documents");
    return response.data;
  } catch (error) {
    console.error("Failed to fetch documents:", error);
    throw new Error("문서를 가져오는데 실패했습니다.");
  }
};

// ✅ 컴포넌트에서 에러 처리
const [error, setError] = useState<string | null>(null);

useEffect(() => {
  const loadDocuments = async () => {
    try {
      setIsLoading(true);
      const data = await fetchDocuments();
      setDocuments(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "알 수 없는 오류가 발생했습니다.");
    } finally {
      setIsLoading(false);
    }
  };

  loadDocuments();
}, []);
```

### 🚀 프로젝트 API 특이사항 (매우 중요!)

#### 기본 원칙

- **백엔드 동기화**: `src/types/api/` 폴더의 타입 정의는 백엔드 객체와 완벽 동기화
- **FormData 통신**: 거의 모든 API가 POST + FormData 형식으로 통신
- **Command/Dto 패턴**: 요청시 Command 접미사, 응답시 Dto 접미사 사용
- **인증 토큰**: AccessToken(sessionStorage) + RefreshToken(쿠키) 방식

#### API 통신 규칙

**✅ 사용해야 할 폴더**

```typescript
src/apis/
├── authApi.ts           // 인증 관련
├── memberApi.ts         // 회원 관련
├── documentPostApi.ts   // 문서 게시물
├── questionPostApi.ts   // 질문 게시물
├── commentApi.ts        // 댓글
├── likeApi.ts          // 좋아요
└── apiUtils.ts         // 공통 유틸리티
```

**❌ 사용 금지 (Deprecated)**

```typescript
src/apis/document/      // 절대 사용하지 말 것
src/apis/question/      // 절대 사용하지 말 것
src/apis/search/        // 절대 사용하지 말 것
```

#### API 함수 구현 패턴

**1. apiUtils 사용 (권장)**

```typescript
import { postApiRequest } from "@/apis/apiUtils";
import type { DocumentCommand } from "@/types/api/requests/documentCommand";
import type { DocumentDto } from "@/types/api/responses/documentDto";

// ✅ apiUtils 사용하는 방법
export const createDocument = async (command: Partial<DocumentCommand>): Promise<DocumentDto> => {
  return await postApiRequest<DocumentCommand, DocumentDto>("/api/documents", command);
};

// ✅ 필요한 props만 직접 전달
export const updateDocument = async (id: string, title: string, content: string): Promise<DocumentDto> => {
  return await postApiRequest<DocumentCommand, DocumentDto>(`/api/documents/${id}`, { title, content });
};
```

**2. 직접 구현 (특수한 경우)**

```typescript
import { apiClient } from "@/apis/appClient";

export const authApi = {
  // ✅ 쿠키 인증이 필요한 경우
  refresh: async (): Promise<AuthDto> => {
    const response = await apiClient.post<AuthDto>("/api/auth/refresh", null, {
      withCredentials: true,
    });

    // AccessToken 자동 저장
    const newAccessToken = response.data.accessToken;
    if (newAccessToken) {
      sessionStorage.setItem("accessToken", newAccessToken);
    }

    return response.data;
  },

  // ✅ FormData 직접 생성하는 경우
  logout: async (command: Partial<AuthCommand>): Promise<void> => {
    const formData = new FormData();
    Object.entries(command).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        formData.append(key, value.toString());
      }
    });

    await apiClient.post("/api/auth/logout", formData, {
      headers: { "Content-Type": "multipart/form-data" },
    });

    // 로그아웃시 토큰 제거
    sessionStorage.removeItem("accessToken");
  },
};
```

#### Command/Dto 타입 사용법

**Command 객체 (요청시)**

```typescript
// src/types/api/requests/documentCommand.ts
export interface DocumentCommand {
  title?: string;
  content?: string;
  categoryId?: string;
  isPrivate?: boolean;
  attachments?: File[];
}

// 사용 예시
const documentCommand: Partial<DocumentCommand> = {
  title: "새 문서",
  content: "문서 내용",
  isPrivate: false,
};
```

**Dto 객체 (응답시)**

```typescript
// src/types/api/responses/documentDto.ts
export interface DocumentDto {
  id: string;
  title: string;
  content: string;
  authorName: string;
  createdAt: string;
  viewCount: number;
  likeCount: number;
}

// 사용 예시
const [documentData, setDocumentData] = useState<DocumentDto | null>(null);
```

#### 인증 토큰 처리

**AccessToken 사용**

```typescript
// apiUtils.ts에서 자동 처리됨
export function getAuthHeaders(): Record<string, string> {
  const token = sessionStorage.getItem("accessToken");
  return {
    "Content-Type": "multipart/form-data",
    ...(token ? { Authorization: `Bearer ${token}` } : {}),
  };
}
```

**RefreshToken 처리**

```typescript
// 쿠키로 자동 전송
const response = await apiClient.post("/api/auth/refresh", null, {
  withCredentials: true, // 쿠키 포함해서 전송
});
```

---

## 🗃️ Redux 상태 관리

### Redux 슬라이스 명명 규칙

#### 파일명 규칙

```typescript
// ✅ 기능 + Slice.ts 형태
bottomSheetSlice.ts; // 바텀시트 관련
modalSlice.ts; // 모달 관련
toastSlice.ts; // 토스트 관련
facultySlice.ts; // 학과 관련
```

#### 슬라이스 구조 패턴

```typescript
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

// 1. State 인터페이스 정의 (기능명 + State)
interface BottomSheetState {
  isOpen: boolean; // Boolean은 반드시 is 접두사
  content: string | null;
  selectedId: string | null;
}

// 2. 초기 상태
const initialState: BottomSheetState = {
  isOpen: false,
  content: null,
  selectedId: null,
};

// 3. 슬라이스 생성
const bottomSheetSlice = createSlice({
  name: "bottomSheet", // 슬라이스 이름 (camelCase)
  initialState,
  reducers: {
    // 4. 액션 명명: 동사 형태 (camelCase)
    setIsOpen: (state, action: PayloadAction<boolean>) => {
      state.isOpen = action.payload;
    },
    showBottomSheet: (state, action: PayloadAction<string>) => {
      state.isOpen = true;
      state.content = action.payload;
    },
    closeBottomSheet: state => {
      state.isOpen = false;
      state.content = null;
      state.selectedId = null;
    },
    updateSelectedId: (state, action: PayloadAction<string>) => {
      state.selectedId = action.payload;
    },
  },
});

// 5. 액션과 리듀서 내보내기
export const { setIsOpen, showBottomSheet, closeBottomSheet, updateSelectedId } = bottomSheetSlice.actions;

export default bottomSheetSlice.reducer;
```

#### 복잡한 상태 관리 패턴

```typescript
// Toast 슬라이스 - 배열 상태 관리 예시
interface Toast {
  id: string;
  title: string;
  description?: string;
  icon?: React.ReactNode;
  color?: "blue" | "green" | "orange";
}

interface ToastState {
  toasts: Toast[]; // 배열 상태
  isVisible: boolean; // 전체 표시 여부
}

const toastSlice = createSlice({
  name: "toast",
  initialState: {
    toasts: [],
    isVisible: false,
  },
  reducers: {
    // 배열에 아이템 추가
    addToast: (state, action: PayloadAction<Toast>) => {
      state.toasts.push(action.payload);
      state.isVisible = true;
    },
    // 특정 아이템 제거
    removeToast: (state, action: PayloadAction<string>) => {
      state.toasts = state.toasts.filter(toast => toast.id !== action.payload);
      if (state.toasts.length === 0) {
        state.isVisible = false;
      }
    },
    // 전체 초기화
    clearAllToasts: state => {
      state.toasts = [];
      state.isVisible = false;
    },
  },
});
```

#### 컴포넌트에서 Redux 사용법

```typescript
import { useSelector, useDispatch } from "react-redux";
import { RootState } from "@/global/store";
import { showBottomSheet, closeBottomSheet } from "@/global/store/bottomSheetSlice";

export default function ComponentName() {
  // 1. useSelector로 상태 조회
  const dispatch = useDispatch();
  const isBottomSheetOpen = useSelector((state: RootState) => state.bottomSheet.isOpen);
  const bottomSheetContent = useSelector((state: RootState) => state.bottomSheet.content);

  // 2. 이벤트 핸들러에서 액션 디스패치
  const handleOpenBottomSheet = () => {
    dispatch(showBottomSheet("바텀시트 내용"));
  };

  const handleCloseBottomSheet = () => {
    dispatch(closeBottomSheet());
  };

  return (
    <div>
      {/* 컴포넌트 내용 */}
    </div>
  );
}
```

#### Redux 변수명 체크리스트

- [ ] 슬라이스 파일명이 `기능명 + Slice.ts` 형태인가?
- [ ] State 인터페이스가 `기능명 + State` 형태인가?
- [ ] Boolean 상태가 `is` 접두사를 사용하는가?
- [ ] 액션명이 동사 형태의 camelCase인가?
- [ ] 슬라이스 name이 camelCase인가?
- [ ] 배열 상태를 다룰 때 불변성을 지키는가?

---

---

## ✨ 코드 품질

### 조건부 렌더링

```typescript
// ✅ 명확한 조건부 렌더링
if (isLoading) {
  return <ComponentSkeleton />;
}

if (error) {
  return <ErrorMessage message={error} />;
}

if (!data || data.length === 0) {
  return <EmptyState message="데이터가 없습니다." />;
}

// ✅ 짧은 조건부 렌더링
return (
  <div>
    {isVisible && <Modal />}
    {count > 0 && <Badge count={count} />}
  </div>
);
```

### 컴포넌트 최적화

```typescript
// ✅ React.memo 사용 (props가 자주 변경되지 않는 경우)
export default React.memo(function ExpensiveComponent({ data }: Props) {
  // 렌더링 비용이 높은 컴포넌트
});

// ✅ useMemo 사용 (계산 비용이 높은 경우)
const expensiveValue = useMemo(() => {
  return data.filter(item => item.isActive).sort(sortByDate);
}, [data]);

// ✅ useCallback 사용 (하위 컴포넌트에 함수를 전달하는 경우)
const handleClick = useCallback(
  (id: string) => {
    onItemClick(id);
  },
  [onItemClick],
);
```

---

## 🔍 개발 체크리스트

새로운 컴포넌트를 만들 때 다음을 반드시 확인하세요:

### ✅ 명명 규칙

- [ ] 컴포넌트명이 PascalCase인가?
- [ ] Boolean 변수에 is/has/can/should 접두사를 사용했는가?
- [ ] 함수명이 동사로 시작하는 camelCase인가?
- [ ] 상수명이 UPPER_SNAKE_CASE인가?

### ✅ 컴포넌트 구조

- [ ] Props 인터페이스를 정의했는가?
- [ ] 필요한 경우 Skeleton 컴포넌트를 만들었는가?
- [ ] 조건부 렌더링을 명확하게 작성했는가?
- [ ] 에러 처리를 적절히 했는가?

### ✅ 스타일링

- [ ] 하드코딩된 색상값 대신 정의된 색상을 사용했는가?
- [ ] 반응형 디자인을 고려했는가?
- [ ] 폰트 클래스를 올바르게 사용했는가?

### ✅ 타입 안전성

- [ ] any 타입을 사용하지 않았는가?
- [ ] API 요청/응답 타입을 정의했는가?
- [ ] Props와 State의 타입을 명확히 정의했는가?

---

## 🚀 Cursor AI 사용법

이제 다음과 같이 Cursor에게 요청하세요:

```
@Branch (Diff with Main Branch) @코드스타일_가이드라인 참고해서 QuestionCard 컴포넌트를 만들어주세요.
- custom-blue 색상 사용
- Pretendard 폰트 적용
- Skeleton 상태 포함
- Props 인터페이스 정의
```

```
@코드스타일_가이드라인 참고해서 이 컴포넌트를 리팩토링해주세요.
- 명명 규칙 준수
- 스타일링 가이드 적용
- 타입 안전성 개선
```

---

**이 가이드라인을 따라 일관성 있고 유지보수하기 쉬운 코드를 작성해주세요! 🎯**
